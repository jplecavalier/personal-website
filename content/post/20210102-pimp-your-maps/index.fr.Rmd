---
title: "Pimp tes cartes!"
authors:
  - jplecavalier
date: 2020-12-13
tags:
  - r
  - r-spatial
  - leaflet
  - sf
image:
  caption: "[Image par Pexels de Pixabay](https://pixabay.com/fr/photos/carte-au-trésor-navigation-carte-1850653/)"
  focal_point: "center"
links:
- icon: file-archive
  icon_pack: fas
  name: "Données"
  url: "data.zip"
output:
  blogdown::html_page:
    css: "/css/custom.css"
    
summary: "Le but de cet article est d'expliquer comment faire des cartes interactives ayant une allure professionnelle en R."
---

Vous est-il déjà arrivé d'être fasciné par l'élégance d'une carte? J'en conviens, pour la majorité d'entre nous (j'en connais qui seraient en désaccord
`r emoji("eyes")`), la visualisation de statistiques classiques sous forme de graphiques est rarement quelque chose d'émouvant. Cependant, en ajoutant un
aspect spatial, ça devient généralement beaucoup plus accrocheur, j'oserais même dire excitant!

<!--more-->

Le but de cet article, comme son titre le laisse sous-entendre, est de vous donner quelques trucs pour *pimper* vos cartes interactives créées en
<i class="fab fa-r-project"></i> pour leur donner une allure professionnelle.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  message  = FALSE,
  warning  = FALSE,
  fig.path = "figs/"
)

options(datatable.print.nrows=10L)
```

## Données utilisées {#donnees-utilisees}

Les différents exemples qui suivront dans l'article illustrent le revenu total médian des ménages en 2015 pour les divisions de recensement de Québec et Lévis.
Ces données sont ouvertes et disponibles [sur le site de Statistiques Canada](https://www12.statcan.gc.ca/census-recensement/2016/dp-pd/prof/index.cfm?Lang=F).
Comme il n'est pas dans la portée d'apprendre à traiter spécifiquement ces données de recensement, j'ai inclus l'ensemble des données requises pour reproduire
les exemples de l'article. Vous pouvez facilement les télécharger en cliquant [ici](data.zip).

Les fichiers inclus sont :

- `cd_qclevis.shp`
- `ada_qclevis.shp`
- `da_qclevis.shp`
- `hydro_qclevis.shp`
- `medincome_qclevis.csvy`

On charge donc ceux-ci en mémoire. Vous verrez dans le bloc de code ci-dessous qu'on utilisera le *package*
[`data.table`](https://rdatatable.gitlab.io/data.table/) pour la gestion des données. Les colonnes spatiales seront de classe `sfc` définie dans le *package*
[`sf`](https://r-spatial.github.io/sf/). Prendre note qu'il y aurait plusieurs autres manières de travailler, comme par exemple utiliser directement la classe
`sf` pour la gestion des données.

```{r load_data}
# On charge les packages
library(data.table)
library(sf)

# On lit les couches spatiales
cd_qclevis <- read_sf("data/cd_qclevis.shp") %>% setDT()
ada_qclevis <- read_sf("data/ada_qclevis.shp") %>% setDT()
da_qclevis <- read_sf("data/da_qclevis.shp") %>% setDT()
hydro_qclevis <- read_sf("data/hydro_qclevis.shp") %>% setDT()

# On lit les données sur le revenu total médian des ménages
medincome_qclevis <- fread("data/medincome_qclevis.csvy", yaml=TRUE)
```

On affiche ensuite ce qu'il y a dans les objets `ada_qclevis` et `medincome_qclevis`.

```{r print_ada}
ada_qclevis[]

medincome_qclevis[]
```

Afin d'être en mesure de créer une carte contenant les informations de revenu moyen, on doit combiner l'information spatiale et tabulaire dans la même table.
Pour ce faire, on utilise la syntaxe de jointure par référence de [`data.table`](https://rdatatable.gitlab.io/data.table/). On affiche ensuite le résultat.

```{r merge_data}
# On fait la jointure
#cd_qclevis[medincome_qclevis[type=="cd"], med_income:=med_income, on=c(CDUID="id")]
ada_qclevis[medincome_qclevis[type=="ada"], med_income:=med_income, on=c(ADAUID="id")]
#da_qclevis[medincome_qclevis[type=="da"], med_income:=med_income, on=c(DAUID="id")]

# On affiche le résultat
ada_qclevis[]
```

On a maintenant tout ce dont on a de besoin pour créer des cartes.

## Carte de base

Avant d'apprendre à *pimper* nos cartes, on commence par produire une carte interactive de base avec le *package*
[`leaflet`](https://rstudio.github.io/leaflet/). Je vous invite à consulter la documentation du *package* pour comprendre l'effet des différentes fonctions.

Le seul point sur lequel j'insisterai est la valeur de l'argument `data` de la fonction `addPolygons()`. Vous remarquerez que j'ai transformé le `data.table`
en objet de classe `sf` (à l'aide de la fonction `st_as_sf()`) et que je l'ai reprojeté en longitude/latitude (à l'aide de la fonction `st_transform()`). Ces
deux étapes sont nécessaires pour faciliter l'intégration avec [`leaflet`](https://rstudio.github.io/leaflet/).

```{r map_base}
# On charge le package
library(leaflet)

# On crée une carte interactive de base
leaflet(width="100%") %>%
  addTiles() %>%
  addPolygons(
    data        = ada_qclevis %>% st_as_sf() %>% st_transform(4326L),
    weight      = 1L,
    color       = gray(0.3),
    opacity     = 1,
    fillColor   = ~colorNumeric(
      palette = "Greens",
      domain  = range(med_income)
    )(med_income),
    fillOpacity = 0.5
  )
```

Cette carte est efficace pour illustrer nos données, mais pourrait facilement être améliorée à l'aide de quelques astuces simples.

## Suggestions d'améliorations

Chacune des améliorations listées dans cette section peut être incorporée à une carte interactive de manière indépendante. Tout dépendamment du contexte,
certains astuces seront plus bénéfiques que d'autres, il n'y a pas de recette universelle. Pour le bien de l'article, les améliorations seront présentées de
manières cumulatives, c'est-à-dire que la deuxième amélioration présentée sera construite par-dessus la première et ainsi de suite.

### Fond de carte

Dans l'exemple simple, on a utilisé les tuiles de fond de carte par défaut de la fonction `addTiles()`. Ces tuiles sont très complètes et présentent
une panoplie d'informations. Souvent, c'est tout simplement trop. Je vous invite donc à choisir judicieusement vos fonds de carte pour mettre l'accent sur ce
que vous cherchez vraiment à illustrer. Vous pouvez facilement voir les tuiles préprogrammées avec [`leaflet`](https://rstudio.github.io/leaflet/)
[ici](https://leaflet-extras.github.io/leaflet-providers/preview/). Pour ma part, mes préférées sont **Positron** et **DarkMatter** du fournisseur **CartoDB**.

Un autre point qu'on peut facilement améliorer avec les tuiles de fond de carte consiste à diviser en deux couches distinctes la couche de base et les
étiquettes. Si vous n'aviez pas remarqué, allez jeter un coup d'oeil à la carte de la section précédente. Comme les polygones sont affichés par-dessus les
tuiles, il devient difficile de lire les étiquettes. Le problème devient encore pire lorsqu'on augmente l'opacité des polygones. La solution pour contourner ce
problème est d'afficher la couche de base en arrière-plan, les étiquettes au premier plan et les polygones en sandwich entre les deux.

Pour ce faire, on va créer trois panneaux de carte avec la fonction `addMapPane()`. L'argument `zIndex` permet de spécifier le niveau de profondeur du panneau.
Plus l'argument `zIndex` est élevé, plus la couche sera vers l'avant.

En appliquant ces deux conseils, on obtient la carte suivante.

```{r map_tiles}
# On améliore les tuiles de fond de carte
leaflet(width="100%") %>%
  addMapPane("background", 100) %>%
  addMapPane("med_income", 400) %>%
  addMapPane("labels", 500) %>%
  addProviderTiles(
    provider = providers$CartoDB.PositronNoLabels,
    options  = pathOptions(pane = "background")
  ) %>%
  addProviderTiles(
    provider = providers$CartoDB.PositronOnlyLabels,
    options  = pathOptions(pane = "labels")
  ) %>%
  addPolygons(
    data        = ada_qclevis %>% st_as_sf() %>% st_transform(4326L),
    weight      = 1L,
    color       = gray(0.3),
    opacity     = 1,
    fillColor   = ~colorNumeric(
      palette = "Greens",
      domain  = range(med_income)
    )(med_income),
    fillOpacity = 0.5,
    options     = pathOptions(
      pane = "med_income"
    )
  )
```

### Domaine de valeurs

Jusqu'à maintenant, on ne s'est pas posé de questions par rapport à l'échelle de couleurs qui est utilisée sur la carte. J'imagine que vous avez déduit qu'on
a spécifié qu'on voulait une échelle de différents verts avec l'argument `palette` qui prend la valeur `"Greens"`. Les plus observateurs auront aussi remarqué
qu'on a spécifié l'étendue de cette échelle à l'aide de l'argument `domain`. Comme la fonction `range()` retourne les valeurs minimale et maximale de son
argument, l'échelle qu'on a défini est linéaire entre le minimum (`r formatC(min(ada_qclevis[, med_income]), format="d", big.mark=" ")` \$) et le maximum
(`r formatC(max(ada_qclevis[, med_income]), format="d", big.mark=" ")` \$) des revenus médians par aire de diffusion agrégée.

Évidemment, cette définition d'échelle n'est pas toujours optimale. Ci-dessous, on affiche la distribution des revenus médians par aire de diffusion agrégée à
l'aide du package [`ggplot2`](https://ggplot2.tidyverse.org/).

```{r hist_domain}
# On charge le package
library(ggplot2)

# On crée un histogramme
ggplot(
  data    = ada_qclevis,
  mapping = aes(
    x = med_income
  )
) +
  geom_bar() +
  scale_x_binned(
    labels = scales::label_number(),
  ) +
  labs(
    x       = "Revenu total médian des ménages en 2015 ($)",
    y       = "Nombre d'aires de diffusion aggrégée",
    caption = "Division de recensement de Québec et Lévis"
  ) +
  theme_minimal()
```

En analysant cet histogramme, on voit qu'une échelle linéaire entre 30 000 \$ 100 000 \$ donnerait probablement un meilleur résultat. Les valeurs à l'extérieur
de cet intervalle seront tronquées à l'aide de la fonction `squish()` du package [`scales`](https://scales.r-lib.org) (déjà chargé avec
[`ggplot2`](https://ggplot2.tidyverse.org/), mais non attaché).

On crée donc une nouvelle carte en y apportant cet ajustement.

```{r map_domain}
# On définit le domaine de valeur sélectionné
med_income_domain <- c(30000L, 100000L)

# On améliore le domaine de valeurs
leaflet(width="100%") %>%
  addMapPane("background", 100) %>%
  addMapPane("med_income", 400) %>%
  addMapPane("labels", 500) %>%
  addProviderTiles(
    provider = providers$CartoDB.PositronNoLabels,
    options  = pathOptions(pane = "background")
  ) %>%
  addProviderTiles(
    provider = providers$CartoDB.PositronOnlyLabels,
    options  = pathOptions(pane = "labels")
  ) %>%
  addPolygons(
    data        = ada_qclevis %>% st_as_sf() %>% st_transform(4326L),
    weight      = 1L,
    color       = gray(0.3),
    opacity     = 1,
    fillColor   = ~colorNumeric(
      palette = "Greens",
      domain  = med_income_domain
    )(scales::squish(med_income, med_income_domain)),
    fillOpacity = 0.5,
    options     = pathOptions(
      pane = "med_income"
    )
  )
```

### Interactions avec le curseur

### Découpage hydrographique

### Granularité dynamique


## Conclusion
